#!/usr/bin/env python
#
# fMBT, free Model Based Testing tool
# Copyright (c) 2011, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU Lesser General Public License,
# version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.

"""
Usage: remote_pyaal [options] aalfile

Runs remote model & adapter written in AAL/Python. aalfile is a
AAL/Python file or Python generated by fmbt-aalc.

Options:
    -c <string>
        execute the string in the Python interpreter before loading
        aalfile.

    -D flag
        pass -D flag to AAL compiler and preprocessor, used in ifdef's.

    -I include-dir
        Pass -I include-dir to AAL compiler and preprocessor. If AAL
        contains ^include "filename"'s, filename will be looked for in
        include-dir.

    -l, -L, --log-file= filename
        Write log to the given file. By default no log is written.
        -l , --log-file overwrites the file, -L appends.

    -t, --timeout s
        Event observation timeout in seconds.

    -o, --output filename
        Convert AAL/Python model to LSTS and write output to given
        file. If filename is "-", output is written to the standard
        output.

    --lsts-depth n
        Stop AAL/Python to LSTS conversion to the given depth. The
        depth is the number of test steps from the initial state.

    -H, --lsts-hide-var varname
        Ignore value of varname when converting to LSTS. States which
        differ only by ignored variables are considered the
        same. --lsts-hide-var can be given several times.

    -S, --lsts-show-var varname
        Take variable varname into account when converting to
        LSTS. --lsts-show-var can be given several times.

    -d, --debug
        Run in debug mode.
"""

import sys
import os
import getopt
import subprocess
import inspect
import time
import fmbt
import atexit
import re
import urllib
import tempfile
import traceback
import StringIO

sys.path.append(os.getcwd())

opt_debug = False
filter_tags = []
log_filename = None
log_flush_interval = 1.0 # in seconds

def _log(msg, flush=False):
    global log_filename
    if opt_debug:
        fmbt._adapterlogWriter(file(log_filename,"a"), fmbt.formatAdapterLogMessage(msg))
        return
    current_time = time.time()
    if log_filename:
        _log.messages.append(fmbt.formatAdapterLogMessage(msg))
        if flush or current_time - _log.last_flush > log_flush_interval:
            log_fileobj = file(log_filename, "a")
            for formatted_msg in _log.messages:
                fmbt._adapterlogWriter(log_fileobj, formatted_msg)
            log_fileobj.close()
            _log.last_flush = current_time
            _log.messages = []
_log.messages = []
_log.last_flush = time.time()

def fmbtlog(msg, flush=True):
    current_time = time.time()
    timestamped = "fmbtmagicl%.4f %s" % (current_time, msg)
    sys.stdout.write(urllib.quote(timestamped)+"\n")

def fmbtstderr(msg):
    to_fmbt = urllib.quote("fmbtmagice%s" % (msg,)) + '\n'
    sys.stdout.write(to_fmbt)
    _log(msg)

fmbt.fmbtlog = fmbtlog
fmbt.adapterlog = _log
log = _log

def error(msg):
    msg = "remote_pyaal error: " + msg + "\n"
    _log(msg)
    sys.stderr.write(msg)
    sys.exit(1)

def bye():
    _g_bridge._aal.aexit(None, None)
    _log("quitting", flush=True)

def put(msg):
    if opt_debug: _log("sending: '%s'" % (msg,))
    sys.stdout.write("fmbtmagic " + str(msg) + "\n")
    sys.stdout.flush()

def put_list(list_of_integers):
    msg = " ".join([str(i) for i in list_of_integers])
    if opt_debug: _log("sending: '%s'" % (msg,))
    sys.stdout.write("fmbtmagic " + msg + "\n")
    sys.stdout.flush()

def put_lts(lts_string):
    if opt_debug: _log("sending lts")
    sys.stdout.write("fmbtmagic %s\n%s" % (len(lts_string), lts_string))
    sys.stdout.flush()

def get():
    cmd = sys.stdin.readline().rstrip()
    if opt_debug: _log("received: '%s'" % (cmd,))
    return cmd

class RemoteAALBridge:
    def __init__(self, aal):
        self._aal = aal

    def communicate(self):
        # send all action names
        action_names = self._aal.getActionNames()
        for name in action_names:
            put(name)
        put("")

        # send all state tags
        tag_names = self._aal.getSPNames()
        for name in tag_names:
            put(name)
        put("")

        # protocol loop
        adapter_call_arguments = []
        cmd = get()
        while cmd != "":
            if cmd == "ma":
                try:
                    put_list(self._aal.getActions())
                except Exception, e:
                    report_simulation_error(self._aal)
                    fmbtstderr('Error when evaluating guards of actions: %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
                    error(str(e))
            elif cmd == "mp":
                try:    put_list(self._aal.getprops())
                except Exception, e:
                    report_simulation_error(self._aal)
                    fmbtstderr('Error at a tag: %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
                    error(str(e))
            elif cmd == "mr":
                try:    self._aal.reset()
                except Exception, e:
                    fmbtstderr('Error at initial_state(): %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
                    put(0)
                else:   put(1)
            elif cmd == "mu":
                self._aal.push()
            elif cmd == "mo":
                self._aal.pop()
            elif cmd.startswith("ae"):
                try:
                    args = cmd[3:]
                    if " " in args: verdict, reason = args.split(" ", 1)
                    else: verdict, reason = args, ""
                    self._aal.aexit(verdict, urllib.unquote(reason))
                except Exception, e:
                    fmbtstderr('Error at adapter_exit(): %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
                    put(0)
                else:
                    put(1)
            elif cmd == "ai":
                try: rv = self._aal.init()
                except Exception, e:
                    fmbtstderr('Error at adapter_init(): %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
                    put(0)
                else:
                    if rv or rv == None: put(1)
                    else: put(0)
            elif cmd == "aop":
                try:
                    put_list(self._aal.observe(False))
                except Exception, e:
                    fmbtstderr('Error when polling outputs: %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
                    error(str(e))
            elif cmd == "aob":
                try:
                    put_list(self._aal.observe(True))
                except Exception, e:
                    fmbtstderr('Error when waiting for outputs: %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
                    error(str(e))
            elif cmd.startswith("act"): # adapter check tags
                # If the adapter of a tag does not return "True" or
                # None, report the number of the first failing tag.
                failing_tags = []
                for tag_number in [int(n) for n in cmd[3:].strip().split()]:
                    try:
                        rv = self._aal.tag_execute(tag_number)
                        if not (rv or rv == None):
                            fmbtstderr('adapter() of tag "%s" returned %s' % (tag_names[tag_number-1], rv))
                            failing_tags.append(tag_number)
                    except Exception, e:
                        if isinstance(e, AssertionError): msg = "Assertion failure"
                        else: msg = "Error"
                        fmbtstderr('%s at adapter() of tag "%s": %s\n%s' % (msg, tag_names[tag_number-1], e, format_pythonaalexception()))
                        if isinstance(e, AssertionError):
                            failing_tags.append(tag_number)
                        else:
                            error(str(e))
                put_list(failing_tags)
            elif cmd[0] == "m":
                action_number = int(cmd[1:])
                try:
                    rv = self._aal.model_execute(action_number)
                except Exception, e:
                    report_simulation_error(self._aal)
                    fmbtstderr('Error at body() of "%s": %s: %s\n%s' % (action_names[action_number-1], type(e).__name__, e, format_pythonaalexception()))
                    error(str(e))
                else:
                    put(rv)
            elif cmd[:2] == "ap":
                adapter_call_arguments.append(cmd[2:])
            elif cmd[0] == "a":
                action_number = int(cmd[1:])
                try:
                    rv = self._aal.adapter_execute(action_number,
                                                   adapter_call_arguments)
                    if (type(rv) == int and (rv == 0 or rv > len(action_names))) or (type(rv) != int and (not rv or rv != None)):
                        fmbtstderr('adapter() of action "%s" returned %s' % (action_names[action_number-1], rv))
                        rv = 0
                except Exception, e:
                    if isinstance(e, AssertionError): msg = "Assertion failure"
                    else: msg = "Error"
                    fmbtstderr('%s at adapter() of "%s": %s: %s\n%s' % (msg, action_names[action_number-1], type(e).__name__, e, format_pythonaalexception()))
                    if isinstance(e, AssertionError):
                        rv = 0
                    else:
                        error(str(e))
                put(rv)
                adapter_call_arguments = []
            elif cmd.startswith("lts"):
                lsts_depth = int(cmd[3:])
                outfilestring = StringIO.StringIO()
                try:
                    self._aal.push()
                    aal2lsts(self._aal, outfilestring, lsts_depth,
                             include_generation_discontinued_tag = False)
                    self._aal.pop()
                except Exception, e:
                    report_simulation_error(self._aal)
                    fmbtstderr('Error on simulation %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
                    error(str(e))
                outfilestring.seek(0)
                put_lts(outfilestring.read())

            else:
                error("Unexpected command: \"" + cmd + "\". remote_pyaal works with \"aal_remote\" model.")
            cmd = get().rstrip()

def format_pythonaalexception():
    if opt_debug:
        # return full tracebacks including framework code
        return traceback.format_exc()
    exc_type, exc_value, exc_tb = sys.exc_info()
    tb = traceback.extract_tb(exc_tb)
    tb.reverse()
    new_tb = []
    for file_line_module_code in tb:
        if file_line_module_code[0].endswith("aalmodel.py"):
            break
        new_tb.append(file_line_module_code)
    new_tb.reverse()
    return 'Traceback (most recent call last):\n' + ''.join(traceback.format_list(new_tb))

def format_syntaxerror():
    """modify last exception filename and line number if it's AAL"""
    redefline = re.compile('    def [a-z0-9_]+\(\):')
    recodefileline = re.compile('setCodeFileLine\(.*\'\'\'(.*)\'\'\', ([-0-9]+)[^0-9]')
    exc_type, exc_value, exc_tb = sys.exc_info()
    tb_tuples = traceback.extract_tb(exc_tb)
    filename, syntaxerrorlineno = exc_value.filename, exc_value.lineno
    try:
        fullsource = file(filename).read()
        fullsourcelines = fullsource.split('\n')
        # syntax error is inside the block that starts on line deflineno
        defline = redefline.findall('\n'.join(fullsourcelines[:syntaxerrorlineno-1]))[-1]
        deflineno = fullsourcelines.index(defline) + 1
        # that block defined is in an aal file given on next setCodeFileLine
        codefile, aalblockstart = recodefileline.findall('\n'.join(fullsourcelines[syntaxerrorlineno-1:]))[0]
        aalblocklineno = syntaxerrorlineno - deflineno
        exc_value.lineno = int(aalblockstart) + aalblocklineno
        exc_value.filename = codefile
        exc_value.args = (exc_value.args[0],
                          (exc_value.filename, exc_value.lineno, exc_value.args[1][2], exc_value.args[1][3]))
        sys.last_value = exc_value
    except:
        pass

def report_simulation_error(aal):
    if len(aal._stack_executed_actions) > 0:
        executed_actions = []
        for l in aal._stack_executed_actions:
            executed_actions.extend(l)
        fmbtstderr("Error after simulated execution:\n    %s" % ('\n    '.join(executed_actions)))

def tagfilter(state,tags):
    global filter_tags
    for tag in filter_tags:
        if tag in tags:
            return tag
    return state

def aal2lsts(aal, output_fileobj, depth=5, discard_variables=set([]),
             include_variables=None, include_generation_discontinued_tag=True,_filter_tags=[]):
    global filter_tags
    try:
        import lsts
    except:
        import fmbt.lsts as lsts

    def update_generated_tags(aal, include_variables,
                              generated_tagnames, tags, new_lsts_state_num):
        for v in include_variables:
            t = "var:%s = %s" % (v, str(aal._variables[v])[:42])
            if not t in generated_tagnames:
                generated_tagnames.add(t)
                tags[t] = []
            tags[t].append(new_lsts_state_num)

    generation_discontinued_tag = "AAL-depth:%s" % (depth,)

    new_lsts = lsts.writer()
    actionnames = ["tau"] + aal.getActionNames()
    # actionname2int = dict([(action, num) for num, action in enumerate(actionnames)])
    transitions = [[]]
    tags = {generation_discontinued_tag: []}
    tagnames = aal.getSPNames()
    generated_tagnames = set([])
    tags.update([(name, []) for name in tagnames])
    tagnum_to_name = dict([(num+1, name) for num, name in enumerate(tagnames)])

    for num,_t in enumerate(tagnames,1):
        if _t in _filter_tags:
            filter_tags.append(num)

    current_tags = aal.getprops()
    initial_state_hidden = tagfilter(aal.state(discard_variables, include_variables), current_tags)
    initial_state_real = aal.state()
    unhandled_states = {initial_state_real: []} # state to shortest path from istate
    found_states_real = {initial_state_real: initial_state_hidden} # real to hidden states
    lsts_states = {initial_state_hidden: 0} # state to LSTS state number
    states = 1

    # initial state tags
    for tag in current_tags:
        tags[tagnum_to_name[tag]].append(lsts_states[initial_state_hidden])
    if include_variables:
        update_generated_tags(aal, include_variables, generated_tagnames, tags, 0)

    while unhandled_states:
        source_state, path = unhandled_states.popitem()
        source_lsts_state = lsts_states[found_states_real[source_state]]

        if len(path) >= depth:
            if not source_lsts_state in tags[generation_discontinued_tag]:
                tags[generation_discontinued_tag].append(lsts_states[found_states_real[source_state]])
            continue

        aal.push()
        for action in path:
            aal.model_execute(action)

        for action in aal.getActions():
            aal.push()
            aal.model_execute(action)
            current_tags = aal.getprops()
            next_state_real = aal.state()
            next_state_hidden = tagfilter(aal.state(discard_variables, include_variables) ,current_tags)
            # new state?
            if not next_state_hidden in lsts_states:
                transitions.append([])
                new_lsts_state_num = len(transitions) - 1
                lsts_states[next_state_hidden] = new_lsts_state_num
                if include_variables:
                    update_generated_tags(aal, include_variables, generated_tagnames, tags, new_lsts_state_num)
            if not next_state_real in found_states_real:
                unhandled_states[next_state_real] = path + [action]
                found_states_real[next_state_real] = next_state_hidden
                next_lsts_state_num = lsts_states[next_state_hidden]
                for tag in current_tags:
                    tagname = tagnum_to_name[tag]
                    if not next_lsts_state_num in tags[tagname]:
                        tags[tagname].append(next_lsts_state_num)
            if (lsts_states[next_state_hidden],action) not in transitions[source_lsts_state]:
                transitions[source_lsts_state].append((lsts_states[next_state_hidden],action))
            aal.pop()
        aal.pop()

    new_lsts.set_actionnames(actionnames)
    new_lsts.set_transitions(transitions)
    new_lsts.set_stateprops(tags)
    stateprop_order = aal.getSPNames() + sorted(generated_tagnames)
    if include_generation_discontinued_tag:
        stateprop_order.append(generation_discontinued_tag)
    new_lsts.write(output_fileobj, stateprop_order=stateprop_order)

if __name__ == "__main__":
    # Default values for commandline arguments
    log_filename = None
    opt_timeout = 1.0
    opt_ppflags = []
    opt_output_fileobj = None
    opt_lsts_depth = 5
    opt_lsts_hide_vars = []
    opt_lsts_show_vars = []
    opt_c_exec_statements = []
    opt_lsts_hide_tags = []

    # Parse arguments
    opts, remainder = getopt.gnu_getopt(
        sys.argv[1:], 'c:dhl:L:t:o:D:H:S:VT:I:',
        ["debug", "help", "log-file=", "timeout=", "output=",
         "lsts-depth=", "lsts-hide-var=", "lsts-show-var=", "version"])

    for opt, arg in opts:
        if opt in ["-T"]:
            opt_lsts_hide_tags.append(arg)
        elif opt in ["-d", "--debug"]:
            opt_debug = True
        elif opt in ["-c"]:
            opt_c_exec_statements.append(arg)
        elif opt in ["-D"]:
            opt_ppflags += ['-D' , arg]
        elif opt in ["-I"]:
            opt_ppflags += ['-I' , arg]
        elif opt in ['-V', '--version']:
            try:
                import fmbt_config
                print "Version " + fmbt_config.fmbt_version + fmbt_config.fmbt_build_info
            except:
                print "Version N/A"
            sys.exit(0)
        elif opt in ["-h", "--help"]:
            print __doc__
            sys.exit(0)
        elif opt in ["-l", "-L", "--log-file"]:
            log_filename = arg
            if opt != "-L": file(log_filename, "w") # overwrite
        elif opt in ["-t", "--timeout"]:
            opt_timeout = float(arg)
            _log("observe timeout: %2.6f" % (opt_timeout,))
        elif opt in ["-o", "--output"]:
            if arg == "-":
                opt_output_fileobj = sys.stdout
            else:
                opt_output_fileobj = file(arg, "w")
        elif opt in ["--lsts-depth"]:
            opt_lsts_depth = int(arg)
        elif opt in ["-H", "--lsts-hide-var"]:
            opt_lsts_hide_vars.append(arg)
        elif opt in ["-S", "--lsts-show-var"]:
            opt_lsts_show_vars.append(arg)

    if len(remainder) != 1:
        print __doc__
        error("aal filename missing")

    aal_filename = remainder[0]

    if aal_filename.endswith(".aal"):
        cmd = ["fmbt-aalc"] + opt_ppflags + [ aal_filename ]
	subout = subprocess.PIPE
	p = subprocess.Popen(cmd,shell=False, stdout=subout,stderr=subout)
	aal_code = p.stdout.read()
	status = p.wait()
        if status != 0:
            fmbtstderr("AAL to Python conversion failed:\n%s" % (aal_code,))
            error("converting aal to python with command\n" +
                  "    %s\nfailed. status=%s" % (cmd, status))
    else:
        try:
            aal_code = file(aal_filename).read()
        except Exception as e:
            error("reading file '%s' failed: %s" % (aal_filename, e))

    for statement in opt_c_exec_statements:
        try:
            _log("Executing command line argument '%s'" % statement)
            exec statement
        except Exception, e:
            fmbtstderr('Exception from command line argument "%s":\n%s' %
                       (statement, traceback.format_exc()))
            error("No exceptions allowed, got '%s':\n%s" %
                  (e, traceback.format_exc()))

    aalpy_fd, aalpy_filename = tempfile.mkstemp(suffix='.py', prefix='remote_pyaal.')
    os.write(aalpy_fd, aal_code)
    os.close(aalpy_fd)
    atexit.register(lambda: os.remove(aalpy_filename))

    try:
        exec file(aalpy_filename)
    except Exception as e:
        if isinstance(e, SyntaxError):
            format_syntaxerror()
        code_lines = aal_code.split('\n')
        code_with_line_nums = ['%4s: %s' % (num+1, line)
                               for num,line in enumerate(code_lines)]
        _log('\n'.join(code_with_line_nums))
        fmbtstderr("Executing %s failed: %s: %s\n%s" %
                   (aal_filename, type(e).__name__, e, traceback.format_exc()))
        error("executing aal code failed:\n%s\n%s" % (e, traceback.format_exc()))

    try:
        # Generated AAL code exports generated AAL class as "Model".
        # Model is inherited from AALModel in aalmodel.py.
        aal = Model()
    except Exception as e:
        error("Error when instantiating Model(): %s\n%s" % (e, traceback.format_exc()))
    aal._log = _log
    aal.timeout = opt_timeout
    aal._variables['fmbtlog'] = fmbtlog
    aal._variables['__file__'] = aal_filename

    if not opt_output_fileobj:
        _g_bridge = RemoteAALBridge(aal)
        _log("starting")
        atexit.register(bye)
        if sys.platform == "win32":
            import os, msvcrt
            msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
            msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)
            msvcrt.setmode(sys.stderr.fileno(), os.O_BINARY)
            suffix=".dll"
        _g_bridge.communicate()
    else:
        aal.reset()
        try:
            aal2lsts(aal, opt_output_fileobj, depth=opt_lsts_depth, discard_variables=set(opt_lsts_hide_vars), include_variables=set(opt_lsts_show_vars),_filter_tags=opt_lsts_hide_tags)
        except Exception, e:
            report_simulation_error(aal)
            fmbtstderr('Error on simulation %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
        opt_output_fileobj.close()
