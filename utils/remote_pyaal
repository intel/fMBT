#!/usr/bin/env python2
#
# fMBT, free Model Based Testing tool
# Copyright (c) 2011, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU Lesser General Public License,
# version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.

"""Usage: remote_pyaal [options] aalfile

Runs remote model & adapter written in AAL/Python. aalfile is a
AAL/Python file or Python generated by fmbt-aalc.

Options:
    -c <string>
        execute the string in the Python interpreter before loading
        aalfile.

    -D flag
        pass -D flag to AAL compiler and preprocessor, used in ifdef's.

    -I include-dir
        Pass -I include-dir to AAL compiler and preprocessor. If AAL
        contains ^include "filename"'s, filename will be looked for in
        include-dir.

    -l, -L, --log-file= filename
        Write log to the given file. By default no log is written.
        -l , --log-file overwrites the file, -L appends.

    --log-unbuffered
        Write log entries to log file on every log function call.
        Slows down high-speed test runs.

    -t, --timeout s
        Event observation timeout in seconds.

    --verbose-fmbt-log
        Write variable values and enabled actions to fMBT log.

    -o, --output filename
        Convert AAL/Python model to LSTS and write output to given
        file. If filename is "-", output is written to the standard
        output.

    --lsts-depth n
        Stop AAL/Python to LSTS conversion to the given depth. The
        depth is the number of test steps from the initial state.

    -H, --lsts-hide-var varname
        Ignore value of varname when converting to LSTS. States which
        differ only by ignored variables are considered the
        same. --lsts-hide-var can be given several times.

    -S, --lsts-show-var varname
        Take variable varname into account when converting to
        LSTS. --lsts-show-var can be given several times.

    --list-state-vars
        Output list of variables that saved for each state.

    --accel-drop-outputs
        Test generation accelerator considers only input actions.
        Safely improves performance outputs in the model are not ment
        to be covered (for instance, they are used for observing
        exceptional behaviour).

    -d, --debug
        Run in debug mode.

    --profile FILE
        Run with profiler, write statistics to FILE.
        Print statistics from FILE with:
        python -c 'import pstats; pstats.Stats("FILE").print_stats()'
"""

import sys
import os
import copy
import getopt
import subprocess
import inspect
import time
import fmbt
import atexit
import re
import urllib
import tempfile
import traceback
import StringIO

sys.path.append(os.getcwd())

opt_debug = 0
opt_profile = None
opt_log_unbuffered = False
filter_tags = []
log_filename = None
log_flush_interval = 1.0 # in seconds

def _log(msg, flush=False):
    global log_filename
    if opt_debug or opt_log_unbuffered:
        fmbt._adapterlogWriter(file(log_filename,"a"), fmbt.formatAdapterLogMessage(msg))
        return
    current_time = time.time()
    if log_filename:
        _log.messages.append(fmbt.formatAdapterLogMessage(msg))
        if flush or current_time - _log.last_flush > log_flush_interval:
            log_fileobj = file(log_filename, "a")
            for formatted_msg in _log.messages:
                fmbt._adapterlogWriter(log_fileobj, formatted_msg)
            log_fileobj.close()
            _log.last_flush = current_time
            _log.messages = []
_log.messages = []
_log.last_flush = time.time()

def fmbtlog(msg, flush=True):
    current_time = time.time()
    timestamped = "fmbtmagicl%.4f %s" % (current_time, msg)
    if isinstance(timestamped, unicode):
        timestamped = timestamped.encode("utf-8")
    sys.stdout.write(urllib.quote(timestamped)+"\n")

def fmbtlograw(msg, flush=True):
    to_fmbt = "fmbtmagicL %s" % (msg,)
    sys.stdout.write(urllib.quote(to_fmbt.encode("utf-8")) + "\n")

def fmbtstderr(msg):
    to_fmbt = "fmbtmagice%s" % (msg,)
    sys.stdout.write(urllib.quote(to_fmbt.encode("utf-8")) + "\n")
    _log(msg)

fmbt.fmbtlog = fmbtlog
fmbt.fmbtlograw = fmbtlograw
fmbt.adapterlog = _log
log = _log

def error(msg):
    msg = "remote_pyaal error: " + msg + "\n"
    _log(msg)
    sys.stderr.write(msg)
    sys.exit(1)

def atexit_remove_file(filename):
    try:
        try:
            os.remove(filename)
        except OSError:
            _log("remote_pyaal error: removing file %s failed when exiting:\n" % (repr(filename),))
            _log(traceback.format_exc(), flush=True)
    except:
        pass

def bye():
    try:
        try:
            _g_bridge._aal.aexit(None, None)
        except:
            _log("remote_pyaal error: exception at AAL adapter_exit failed when exiting:\n")
            _log(format_pythonaalexception())
        _log("quitting", flush=True)
    except:
        pass

def put(msg):
    if opt_debug: _log("sending: '%s'" % (msg,))
    sys.stdout.write("fmbtmagic " + str(msg) + "\n")
    sys.stdout.flush()

def put_list(list_of_integers):
    msg = " ".join([str(i) for i in list_of_integers])
    if opt_debug: _log("sending: '%s'" % (msg,))
    sys.stdout.write("fmbtmagic " + msg + "\n")
    sys.stdout.flush()

def put_lts(lts_string):
    if opt_debug:
        if opt_debug == 1:
            _log("sending lts (add another --debug to see it)")
        elif opt_debug > 1:
            _log("sending lts\n%s\n" % (lts_string,))
    sys.stdout.write("fmbtmagic %s\n%s" % (len(lts_string), lts_string))
    sys.stdout.flush()

def get():
    cmd = sys.stdin.readline().rstrip()
    if opt_debug: _log("received: '%s'" % (cmd,))
    return cmd

def log_version():
    try:
        import fmbt_config
        fmbtlograw("<remote_pyaal_version>" + fmbt_config.fmbt_version +
                   fmbt_config.fmbt_build_info+"</remote_pyaal_version>\n")
    except:
        fmbtlograw("<remote_pyaal_version>N/A</remote_pyaal_version>\n")

class RemoteAALBridge:
    def __init__(self, aal):
        self._aal = aal

    def communicate(self):
        # send all action names
        action_names = self._aal.getActionNames()
        for name in action_names:
            put(name)
        put("")

        # send all state tags
        tag_names = self._aal.getSPNames()
        for name in tag_names:
            put(name)
        put("")

        # Write version information
        log_version()

        # protocol loop
        adapter_call_arguments = []
        cmd = get()
        while cmd != "":
            if cmd == "ma":
                try:
                    put_list(self._aal.getActions())
                except Exception, e:
                    report_simulation_error(self._aal)
                    fmbtstderr('Error when evaluating guards of actions: %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
                    error(str(e))
            elif cmd == "mp":
                try:    put_list(self._aal.getprops())
                except Exception, e:
                    report_simulation_error(self._aal)
                    fmbtstderr('Error at a tag: %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
                    error(str(e))
            elif cmd == "mr":
                try:    self._aal.reset()
                except Exception, e:
                    fmbtstderr('Error at initial_state(): %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
                    put(0)
                else:   put(1)
            elif cmd == "mu":
                self._aal.push()
            elif cmd == "mo":
                self._aal.pop()
            elif cmd.startswith("ae"):
                try:
                    args = cmd[3:]
                    if " " in args: verdict, reason = args.split(" ", 1)
                    else: verdict, reason = args, ""
                    self._aal.aexit(verdict, urllib.unquote(reason))
                except Exception, e:
                    fmbtstderr('Error at adapter_exit(): %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
                    put(0)
                else:
                    put(1)
            elif cmd == "ai":
                try: rv = self._aal.init()
                except Exception, e:
                    fmbtstderr('Error at adapter_init(): %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
                    put(0)
                else:
                    if rv or rv == None: put(1)
                    else: put(0)
            elif cmd == "aop":
                try:
                    put_list(self._aal.observe(False))
                except Exception, e:
                    fmbtstderr('Error when polling outputs: %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
                    error(str(e))
            elif cmd == "aob":
                try:
                    put_list(self._aal.observe(True))
                except Exception, e:
                    fmbtstderr('Error when waiting for outputs: %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
                    error(str(e))
            elif cmd.startswith("act"): # adapter check tags
                # If the adapter of a tag does not return "True" or
                # None, report the number of the first failing tag.
                failing_tags = []
                # Tags must not change model state
                _state_before_tag = self._aal.state()
                for tag_number in [int(n) for n in cmd[3:].strip().split()]:
                    try:
                        rv = self._aal.tag_execute(tag_number)
                        if not (rv or rv == None):
                            fmbtstderr('adapter() of tag "%s" returned %s' % (tag_names[tag_number-1], rv))
                            failing_tags.append(tag_number)
                        if self._aal.state() != _state_before_tag:
                            raise Exception('model state changed by tag adapter')
                    except Exception, e:
                        if isinstance(e, AssertionError): msg = "Assertion failure"
                        else: msg = "Error"
                        fmbtstderr('%s at adapter() of tag "%s": %s\n%s' % (msg, tag_names[tag_number-1], e, format_pythonaalexception()))
                        if isinstance(e, AssertionError):
                            failing_tags.append(tag_number)
                        else:
                            error(str(e))
                put_list(failing_tags)
            elif cmd[0] == "m":
                if opt_verbose_fmbt_log and not fmbt.simulated():
                    # write variable values to fmbt log
                    state_str = self._aal.state()
                    log_str = "AAL state: %s\n%s" % (state_str.count("\n") + 1, state_str)
                    # write enabled actions to fmbt log
                    try:
                        log_str += "\nAAL enabled: " + " ".join(
                            [str(s) for s in self._aal._enabled_actions_stack[-1]])
                    except IndexError:
                        pass
                    fmbtlog(log_str)
                action_number = int(cmd[1:])
                try:
                    rv = self._aal.model_execute(action_number)
                except Exception, e:
                    report_simulation_error(self._aal)
                    fmbtstderr('Error at body() of "%s": %s: %s\n%s' % (action_names[action_number-1], type(e).__name__, e, format_pythonaalexception()))
                    error(str(e))
                else:
                    put(rv)
            elif cmd[:2] == "ap":
                adapter_call_arguments.append(cmd[2:])
            elif cmd[0] == "a":
                action_number = int(cmd[1:])
                try:
                    rv = self._aal.adapter_execute(action_number,
                                                   adapter_call_arguments)
                    if rv == None or rv is True:
                        rv = action_number
                    if (type(rv) == int and (rv == 0 or rv > len(action_names))) or (type(rv) != int):
                        fmbtstderr('adapter() of action "%s" returned %s' % (action_names[action_number-1], rv))
                        rv = 0
                except Exception, e:
                    if isinstance(e, AssertionError): msg = "Assertion failure"
                    else: msg = "Error"
                    fmbtstderr('%s at adapter() of "%s": %s: %s\n%s' % (msg, action_names[action_number-1], type(e).__name__, e, format_pythonaalexception()))
                    if isinstance(e, AssertionError):
                        rv = 0
                    else:
                        error(str(e))
                put(rv)
                adapter_call_arguments = []
            elif cmd.startswith("lts"):
                lsts_depth = int(cmd[3:])
                outfilestring = StringIO.StringIO()
                try:
                    aal2lsts(self._aal, outfilestring, lsts_depth,
                             include_generation_discontinued_tag=False,
                             drop_outputs=opt_accel_drop_outputs)
                except Exception, e:
                    report_simulation_error(self._aal)
                    fmbtstderr('Error on simulation %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
                    error(str(e))
                outfilestring.seek(0)
                put_lts(outfilestring.read())

            else:
                error("Unexpected command: \"" + cmd + "\". remote_pyaal works with \"aal_remote\" model.")
            cmd = get().rstrip()

def format_pythonaalexception():
    if opt_debug:
        # return full tracebacks including framework code
        return traceback.format_exc()
    exc_type, exc_value, exc_tb = sys.exc_info()
    tb = traceback.extract_tb(exc_tb)
    tb.reverse()
    new_tb = []
    for file_line_module_code in tb:
        if file_line_module_code[0].endswith("aalmodel.py"):
            break
        new_tb.append(file_line_module_code)
    new_tb.reverse()
    return 'Traceback (most recent call last):\n' + ''.join(traceback.format_list(new_tb))

def format_syntaxerror():
    """modify last exception filename and line number if it's AAL"""
    redefline = re.compile('    def [a-z0-9_]+\(\):')
    recodefileline = re.compile('setCodeFileLine\(.*\'\'\'(.*)\'\'\', ([-0-9]+)[^0-9]')
    exc_type, exc_value, exc_tb = sys.exc_info()
    tb_tuples = traceback.extract_tb(exc_tb)
    filename, syntaxerrorlineno = exc_value.filename, exc_value.lineno
    try:
        fullsource = file(filename).read()
        fullsourcelines = fullsource.split('\n')
        # syntax error is inside the block that starts on line deflineno
        defline = redefline.findall('\n'.join(fullsourcelines[:syntaxerrorlineno-1]))[-1]
        deflineno = fullsourcelines.index(defline) + 1
        # that block defined is in an aal file given on next setCodeFileLine
        codefile, aalblockstart = recodefileline.findall('\n'.join(fullsourcelines[syntaxerrorlineno-1:]))[0]
        aalblocklineno = syntaxerrorlineno - deflineno
        exc_value.lineno = int(aalblockstart) + aalblocklineno
        exc_value.filename = codefile
        exc_value.args = (exc_value.args[0],
                          (exc_value.filename, exc_value.lineno, exc_value.args[1][2], exc_value.args[1][3]))
        sys.last_value = exc_value
    except:
        pass

def report_simulation_error(aal):
    if len(aal._stack_executed_actions) > 0:
        executed_actions = []
        for l in aal._stack_executed_actions:
            executed_actions.extend(l)
        fmbtstderr("Error after simulated execution:\n    %s" % ('\n    '.join(executed_actions)))

def tagfilter(state, tags):
    global filter_tags
    for tag in filter_tags:
        if tag in tags:
            return tag
    return state

def aal2lsts(aal, output_fileobj, depth=5, discard_variables=None,
             include_variables=None, include_generation_discontinued_tag=True,
             _filter_tags=None, drop_outputs=False):
    global filter_tags
    try:
        import lsts
    except:
        import fmbt.lsts as lsts

    def update_generated_tags(aal, include_variables,
                              generated_tagnames, tags, new_lsts_state_num):
        for v in include_variables:
            t = "var:%s = %s" % (v, repr(aal._variables[v])[:42])
            if not t in generated_tagnames:
                generated_tagnames.add(t)
                tags[t] = []
            tags[t].append(new_lsts_state_num)

    if drop_outputs:
        get_actions = aal.getIActions
    else:
        get_actions = aal.getActions

    aal.push()
    generation_discontinued_tag = "AAL-depth:%s" % (depth,)

    new_lsts = lsts.writer()
    actionnames = ["tau"] + aal.getActionNames()
    transitions = [[]]
    tags = {generation_discontinued_tag: []}
    tagnames = aal.getSPNames()
    generated_tagnames = set([])
    tags.update([(name, []) for name in tagnames])
    tagnum_to_name = dict([(num+1, name) for num, name in enumerate(tagnames)])

    for num,_t in enumerate(tagnames,1):
        if _filter_tags and _t in _filter_tags:
            filter_tags.append(num)

    current_tags = aal.getprops()
    initial_state_hidden = tagfilter(aal.state(discard_variables, include_variables), current_tags)
    initial_state_real = aal.state()
    # unhandled states is a list of
    # (state-string, state-obj, len(shortest path from the initial state))
    unhandled_states = [(initial_state_real, aal.state_obj(), 0)]
    found_states_real = {initial_state_real: initial_state_hidden} # real to hidden states
    lsts_states = {initial_state_hidden: 0} # state to LSTS state number
    states = 1

    no_filtering_nor_abstracting = (not discard_variables and
                                    not include_variables and
                                    not _filter_tags)

    # initial state tags
    for tag in current_tags:
        tags[tagnum_to_name[tag]].append(lsts_states[initial_state_hidden])
    if include_variables:
        update_generated_tags(aal, include_variables, generated_tagnames, tags, 0)

    while unhandled_states:
        source_state, source_state_obj, source_state_depth = unhandled_states.pop(0)
        source_lsts_state = lsts_states[found_states_real[source_state]]

        if source_state_depth >= depth:
            if (include_generation_discontinued_tag and
                not source_lsts_state in tags[generation_discontinued_tag]):
                tags[generation_discontinued_tag].append(source_lsts_state)
            continue

        aal.set_state_obj(source_state_obj)
        for action in get_actions():
            aal.set_state_obj(aal.state_obj_copy(source_state_obj))
            aal.model_execute(action)
            current_tags = aal.getprops()
            next_state_real = aal.state()
            if no_filtering_nor_abstracting:
                next_state_hidden = next_state_real
            else:
                if discard_variables or include_variables:
                    next_state_hidden = tagfilter(aal.state(discard_variables, include_variables), current_tags)
                else:
                    next_state_hidden = tagfilter(next_state_real, current_tags)
            next_state_obj = aal.state_obj()
            # new state?
            if not next_state_hidden in lsts_states:
                transitions.append([])
                new_lsts_state_num = len(transitions) - 1
                lsts_states[next_state_hidden] = new_lsts_state_num
                if include_variables:
                    update_generated_tags(aal, include_variables, generated_tagnames, tags, new_lsts_state_num)
            if not next_state_real in found_states_real:
                unhandled_states.append(
                    (next_state_real, next_state_obj, source_state_depth + 1))
                found_states_real[next_state_real] = next_state_hidden
                next_lsts_state_num = lsts_states[next_state_hidden]
                for tag in current_tags:
                    tagname = tagnum_to_name[tag]
                    if not next_lsts_state_num in tags[tagname]:
                        tags[tagname].append(next_lsts_state_num)
            if (lsts_states[next_state_hidden],action) not in transitions[source_lsts_state]:
                transitions[source_lsts_state].append((lsts_states[next_state_hidden],action))

    new_lsts.set_actionnames(actionnames)
    new_lsts.set_transitions(transitions)
    new_lsts.set_stateprops(tags)
    stateprop_order = aal.getSPNames() + sorted(generated_tagnames)
    if include_generation_discontinued_tag:
        stateprop_order.append(generation_discontinued_tag)
    new_lsts.write(output_fileobj, stateprop_order=stateprop_order)
    aal.pop()

if __name__ == "__main__":
    # Default values for commandline arguments
    log_filename = None
    opt_timeout = 1.0
    opt_ppflags = []
    opt_output_fileobj = None
    opt_verbose_fmbt_log = 0
    opt_lsts_depth = 5
    opt_lsts_hide_vars = []
    opt_lsts_show_vars = []
    opt_c_exec_statements = []
    opt_lsts_hide_tags = []
    opt_list_state_vars = False
    opt_accel_drop_outputs = False

    # Parse arguments
    opts, remainder = getopt.gnu_getopt(
        sys.argv[1:], 'c:dhl:L:t:o:D:H:S:VT:I:',
        ["debug", "help", "log-file=", "timeout=", "output=",
         "verbose-fmbt-log", "accel-drop-outputs",
         "lsts-depth=", "lsts-hide-var=", "lsts-show-var=",
         "log-unbuffered",
         "list-state-vars", "profile=", "version"])

    for opt, arg in opts:
        if opt in ["-T"]:
            opt_lsts_hide_tags.append(arg)
        elif opt in ["-d", "--debug"]:
            opt_debug += 1
        elif opt in ["-c"]:
            opt_c_exec_statements.append(arg)
        elif opt in ["-D"]:
            opt_ppflags += ['-D' , arg]
        elif opt in ["-I"]:
            opt_ppflags += ['-I' , arg]
        elif opt in ['-V', '--version']:
            try:
                import fmbt_config
                print "Version " + fmbt_config.fmbt_version + fmbt_config.fmbt_build_info
            except:
                print "Version N/A"
            sys.exit(0)
        elif opt in ["-h", "--help"]:
            print __doc__
            sys.exit(0)
        elif opt in ["-l", "-L", "--log-file"]:
            log_filename = arg
            if opt != "-L": file(log_filename, "w") # overwrite
        elif opt in ["--log-unbuffered"]:
            opt_log_unbuffered = True
        elif opt in ["-t", "--timeout"]:
            opt_timeout = float(arg)
            _log("observe timeout: %2.6f" % (opt_timeout,))
        elif opt in ["--verbose-fmbt-log"]:
            opt_verbose_fmbt_log += 1
        elif opt in ["-o", "--output"]:
            if arg == "-":
                opt_output_fileobj = sys.stdout
            else:
                opt_output_fileobj = file(arg, "w")
        elif opt in ["--lsts-depth"]:
            opt_lsts_depth = int(arg)
        elif opt in ["-H", "--lsts-hide-var"]:
            opt_lsts_hide_vars.append(arg)
        elif opt in ["-S", "--lsts-show-var"]:
            opt_lsts_show_vars.append(arg)
        elif opt in ["--list-state-vars"]:
            opt_list_state_vars = True
            if not opt_output_fileobj:
                opt_output_fileobj = sys.stdout
        elif opt in ["--accel-drop-outputs"]:
            opt_accel_drop_outputs = True
        elif opt in ["--profile"]:
            opt_profile = arg

    if len(remainder) != 1:
        print __doc__
        error("aal filename missing")

    aal_filename = remainder[0]

    if aal_filename.endswith(".aal"):
        cmd = ["fmbt-aalc", "-l", "python"] + opt_ppflags + [ aal_filename ]
        subout = subprocess.PIPE
        p = subprocess.Popen(cmd,shell=False, stdout=subout,stderr=subout)
        aal_code = p.stdout.read()
        status = p.wait()
        if status != 0:
            if not os.access(aal_filename, os.R_OK):
                errmsg = 'is file "%s" readable?' % (aal_filename,)
            else:
                errmsg = ("converting aal to python with command\n    %s\n"
                          "failed. status=%s\n%s\n" % (cmd, status, p.stderr.read()))
            fmbtstderr(errmsg)
            error(errmsg)
        else:
            if not os.access(aal_filename, os.R_OK):
                errmsg = 'is file "%s" readable?' % (aal_filename,)
                fmbtstderr(errmsg)
            fmbtstderr(cmd)
            fmbtstderr(os.path.dirname(os.path.realpath(__file__)))
            
    else:
        try:
            aal_code = file(aal_filename).read()
        except Exception as e:
            error("reading file '%s' failed: %s" % (aal_filename, e))

    for statement in opt_c_exec_statements:
        try:
            _log("Executing command line argument '%s'" % statement)
            exec statement
        except Exception, e:
            fmbtstderr('Exception from command line argument "%s":\n%s' %
                       (statement, traceback.format_exc()))
            error("No exceptions allowed, got '%s':\n%s" %
                  (e, traceback.format_exc()))

    aalpy_fd, aalpy_filename = tempfile.mkstemp(suffix='.py', prefix='remote_pyaal.')
    aal_code = aal_code.replace("\r\n", "\n")
    os.write(aalpy_fd, aal_code)
    os.close(aalpy_fd)
    atexit.register(lambda: atexit_remove_file(aalpy_filename))

    try:
        exec file(aalpy_filename)
    except Exception as e:
        if isinstance(e, SyntaxError):
            format_syntaxerror()
        code_lines = aal_code.split('\n')
        code_with_line_nums = ['%4s: %s' % (num+1, line)
                               for num,line in enumerate(code_lines)]
        _log('\n'.join(code_with_line_nums))
        fmbtstderr("Executing %s failed: %s: %s\n%s" %
                   (aal_filename, type(e).__name__, e, traceback.format_exc()))
        error("executing aal code failed:\n%s\n%s" % (e, traceback.format_exc()))

    try:
        # Generated AAL code exports generated AAL class as "Model".
        # Model is inherited from AALModel in aalmodel.py.
        aal = Model()
    except Exception as e:
        error("Error when instantiating Model(): %s\n%s" % (e, traceback.format_exc()))
    aal._log = _log
    aal.timeout = opt_timeout
    aal._variables['fmbtlog'] = fmbtlog
    aal._variables['fmbtlograw'] = fmbtlograw
    aal._variables['__file__'] = aal_filename

    if opt_profile:
        import cProfile
        profiler = cProfile.Profile()
        profiler.enable()

    if not opt_output_fileobj:
        _g_bridge = RemoteAALBridge(aal)
        _log("starting")
        atexit.register(bye)
        if sys.platform == "win32":
            import os, msvcrt
            msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
            msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)
            msvcrt.setmode(sys.stderr.fileno(), os.O_BINARY)
            suffix=".dll"
        _g_bridge.communicate()
    elif opt_list_state_vars:
        aal.reset()
        opt_output_fileobj.write(
            "\n".join([l.split(" = ",1)[0]
                       for l in sorted(aal.state().splitlines())]))
        opt_output_fileobj.write("\n")
        opt_output_fileobj.close()
    else: # output LSTS
        aal.reset()
        try:
            aal2lsts(aal, opt_output_fileobj, depth=opt_lsts_depth, discard_variables=set(opt_lsts_hide_vars), include_variables=set(opt_lsts_show_vars),_filter_tags=opt_lsts_hide_tags)
        except Exception, e:
            report_simulation_error(aal)
            fmbtstderr('Error on simulation %s: %s\n%s' % (type(e).__name__, e, format_pythonaalexception()))
        opt_output_fileobj.close()

    if opt_profile:
        profiler.disable()
        s = profiler.dump_stats(opt_profile)
