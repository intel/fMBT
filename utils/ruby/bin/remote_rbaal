#!/usr/bin/env ruby
#
# fMBT, free Model Based Testing tool
# Copyright (c) 2011, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU Lesser General Public License,
# version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.

=begin
Usage remote_rbaal [options] aalfile

Runs remote model & adapter written in AAL/Ruby. aalfile is a
AAL/Ruby file or Python generated by fmbt-aalc.

Options
   -c <string>
       execute the string in the Python interpreter before loading
       aalfile.

   -D flag
       pass -D flag to AAL compiler and preprocessor, used in ifdef's.

   -I include-dir
       Pass -I include-dir to AAL compiler and preprocessor. If AAL
       contains ^require 'filename's, filename will be looked for in
       include-dir.

   -l, -L, --log-file= filename
       Write log to the given file. By default no log is written.
       -l , --log-file overwrites the file, -L pushs.

   --log-unbuffered
       Write log entries to log file on every log function call.
       Slows down high-speed test runs.

   -t, --timeout s
       Event observation timeout in seconds.

   --verbose-fmbt-log
       Write variable values and enabled actions to fMBT log.

   -o, --output filename
       Convert AAL/Ruby model to LSTS and write output to given
       file. If filename is "-", output is written to the standard
       output.

   --lsts-depth n
       Stop AAL/Ruby to LSTS conversion to the given depth. The
       depth is the number of test steps from the initial state.

   -H, --lsts-hide-var varname
       Ignore value of varname when converting to LSTS. States which
       differ only by ignored variables are considered the
       same. --lsts-hide-var can be given several times.

   -S, --lsts-show-var varname
       Take variable varname into account when converting to
       LSTS. --lsts-show-var can be given several times.

   --list-state-vars
       Output list of variables that saved for each state.

   --accel-drop-outputs
       Test generation accelerator considers only input actions.
       Safely improves performance outputs in the model are not ment
       to be covered (for instance, they are used for observing
       rescueional behaviour).

   -d, --debug
       Run in debug mode.

   --profile FILE
       Run with profiler, write statistics to FILE.
       Print statistics from FILE with
=end

require 'rubygems'
require 'fmbt-ruby'
require 'fmbt'
require 'getoptlong'
require 'cgi'
require 'date'
require 'time'
require 'tempfile'
require "stringio"
if RUBY_VERSION.include?('1.8') or RUBY_VERSION.include?('1.9')
    require 'iconv'
end

$opt_debug = false
$opt_profile = nil
$opt_log_unbuffered = false
$filter_tags = []
$log_filename = nil
$log_flush_interval = 1.0 # in seconds


module RemoteRBAAL
    extend self

    module MyLog
        @messages = []
        @last_flush = DateTime.new()
    

        def self.log(msg, flush=false)
            if $opt_debug or $opt_log_unbuffered
                Fmbt._adapterlogWriter(File.new($log_filename,"a"), Fmbt.formatAdapterLogMessage(msg))
                return
            end
            current_time = DateTime.new()
            if $log_filename
                self.messages.push(Fmbt.formatAdapterLogMessage(msg))
                if flush or current_time - self.last_flush > $log_flush_interval
                    log_fileobj = file($log_filename, "a")
                    for formatted_msg in self.messages
                        Fmbt._adapterlogWriter(log_fileobj, formatted_msg)
                    end
                    log_fileobj.close()
                    self.last_flush = current_time
                    self.messages = []
                end
            end
        end
    end

    def fmbtlog(msg, flush=true)
        current_time = Time.now.to_i
        timestamped = "fmbtmagicl#{current_time} #{msg}"
        $stdout.write(CGI::escape(timestamped)+"\n")
    end

    def fmbtlograw(msg, flush=true)
        to_fmbt = "fmbtmagicL #{msg}"
        $stdout.write(CGI::escape(to_Fmbt.encode("utf-8")) + "\n")
    end

    def fmbtstderr(msg)
        to_fmbt = "fmbtmagice#{msg}"
        if RUBY_VERSION.include?('1.8') or RUBY_VERSION.include?('1.9')
            $stdout.write(CGI::escape(Iconv.iconv('UTF-8//IGNORE', 'UTF-8',to_fmbt)[0]) + "\n")
        else
            $stdout.write(CGI::escape(to_fmbt.encode("UTF-8")[0]) + "\n")
        end
        MyLog.log(msg)
    end

    # Fmbt.fmbtlog = fmbtlog
    # Fmbt.fmbtlograw = fmbtlograw
    # Fmbt.adapterlog = MyLog
    log = MyLog

    def error(msg)
        msg = "remote_rbaal error " + msg + "\n"
        MyLog.log(msg)
        $stderr.write(msg)
        exit(1)
    end

    def atexit_remove_file(filename)
        begin
            begin
                os.remove(filename)
            rescue RuntimeError
                MyLog("remote_rbaal error removing file #{filename} failed when exiting\n")
            end
        rescue
        end
            
    end

    def bye(g_bridge)
        begin
            begin
                g_bridge.aal.aexit(nil, nil)
            rescue
                MyLog("remote_rbaal error rescueion at AAL adapter_exit failed when exiting\n")
                MyLog(format_pythonaalrescueion())
            end
            MyLog("quitting", flush=true)
        rescue
        end
    end

    def put(msg)
        if $opt_debug    
            MyLog("sending '#{msg}'")
        end
        $stdout.write("fmbtmagic #{msg}\n")
        $stdout.flush()
    end

    def put_list(list_of_integers)
        msg = list_of_integers.join(" ")
        if $opt_debug 
            MyLog("sending 'msg'")
        end
        $stdout.write("fmbtmagic " + msg + "\n")
        $stdout.flush()
    end

    def put_lts(lts_string)
        if $opt_debug
            if $opt_debug == 1
                MyLog("sending lts (add another --debug to see it)")
            elsif $opt_debug > 1
                MyLog("sending lts\n#{lts_string}\n")
            end
        end
        $stdout.write("fmbtmagic #{lts_string.encode("UTF-8").bytes.length}\n#{lts_string}")
        $stdout.flush()
    end

    def get()
        cmd = sys.stdin.readline().rstrip()
        if $opt_debug 
            MyLog("received '#{cmd}'")
        end
        return cmd
    end

    def log_version()
        begin
            import fmbt_config
            fmbtlograw("<remote_rbaal_version>" + fmbt_config.fmbt_version +
                    fmbt_config.fmbt_build_info+"</remote_rbaal_version>\n")
        rescue
            fmbtlograw("<remote_rbaal_version>N/A</remote_rbaal_version>\n")
        end
    end

    class RemoteAALBridge
        def initialize(aal)
            @aal = aal
        end
        
        def communicate()
            # send all action names
            action_names = @aal.getActionNames()
            for name in action_names
                RemoteRBAAL.put(name)
            end
            RemoteRBAAL.put("")

            # send all state tags
            tag_names = @aal.getSPNames()
            for name in tag_names
                RemoteRBAAL.put(name)
            end
            RemoteRBAAL.put("")

            # Write version information
            # log_version()

            # protocol loop
            adapter_call_arguments = []
            cmd = $stdin.gets
            while cmd != "" and cmd != nil
                cmd = cmd.chomp
                cmd = cmd.strip
                if cmd == "ma"
                    begin
                        RemoteRBAAL.put_list(@aal.getActions())
                    rescue Exception=>e
                        report_simulation_error(@aal)
                        RemoteRBAAL.fmbtstderr("Error when evaluating guards of actions #{e.class} #{e.message}\n#{format_rubyaalrescueion()}")
                        raise Exception.new(e.message)
                    end
                elsif cmd == "mp"
                    begin    
                        RemoteRBAAL.put_list(@aal.getprops())
                    rescue Exception=>e
                        report_simulation_error(@aal)
                        RemoteRBAAL.fmbtstderr('Error at a tag #{e.class} #{e.message}\n#{format_rubyaalrescueion()}')
                        raise Exception.new(e.message)
                    end
                elsif cmd == "mr"
                    
                    begin
                        @aal.reset()
                    rescue Exception=>e
                        RemoteRBAAL.fmbtstderr('Error at initial_state() #{e.class} #{e.message}\n#{format_rubyaalrescueion()}')
                        RemoteRBAAL.put(0)
                    else   
                        RemoteRBAAL.put(1)
                    end
                elsif cmd == "mu"
                    @aal.push()
                elsif cmd == "mo"
                    @aal.pop()
                elsif cmd[0..1] == "ae"
                    begin
                        args = cmd.split()[1]
                        if args.include?(" ")
                            verdict, reason = args.split(" ", 1)
                        else 
                            verdict, reason = args, ""
                        end
                        @aal.aexit(verdict, CGI::unescape(reason))
                    rescue Exception=>e
                        RemoteRBAAL.fmbtstderr('Error at adapter_exit() #{e.class} #{e.message}\n#{format_rubyaalrescueion()}')
                        RemoteRBAAL.put(0)
                    else
                        RemoteRBAAL.put(1)
                    end
                elsif cmd == "ai"
                    begin
                        rv = @aal.init()
                    rescue Exception=>e
                        RemoteRBAAL.fmbtstderr('Error at adapter_init() #{e.class} #{e.message}\n#{format_rubyaalrescueion()}')
                        RemoteRBAAL.put(0)
                    else
                        if rv or rv == nil 
                            RemoteRBAAL.put(1)
                        else 
                            RemoteRBAAL.put(0)
                        end
                    end
                elsif cmd == "aop"
                    begin
                        RemoteRBAAL.put_list(@aal.observe(false))
                    rescue Exception=>e
                        RemoteRBAAL.fmbtstderr('Error when polling outputs #{e.class} #{e.message}\n#{format_rubyaalrescueion()}')
                        raise Exception.new(e.message)
                    end
                elsif cmd == "aob"
                    begin
                        RemoteRBAAL.put_list(@aal.observe(true))
                    rescue Exception=>e
                        RemoteRBAAL.fmbtstderr('Error when waiting for outputs #{e.class} #{e.message}\n#{format_rubyaalrescueion()}')
                        raise Exception.new(e.message)
                    end
                elsif cmd[0..2] == "act" # adapter check tags
                    # If the adapter of a tag does not return "true" or
                    # nil, report the number of the first failing tag.
                    failing_tags = []
                    # Tags must not change model state
                    _state_before_tag = @aal.state()
                    for tag_number in cmd.split()[1..-1]
                        tag_number = tag_number.to_i
                        begin
                            rv = @aal.tag_execute(tag_number)
                            if not (rv or rv == nil)
                                RemoteRBAAL.fmbtstderr("adapter() of tag \"#{tag_names[tag_number-1]}\" returned #{rv}")
                                failing_tags.push(tag_number)
                            end
                            if @aal.state() != _state_before_tag
                                raise Exception.new('model state changed by tag adapter')
                            end
                        rescue Exception=>e
                            #todo: find  what is Assertion for
                            msg = "Assertion failure"
                            RemoteRBAAL.fmbtstderr("#{msg} at adapter() of tag \"#{tag_names[tag_number-1]}\" #{e.message}\n#{format_rubyaalrescueion()}")
                            failing_tags.push(tag_number)
                        end
                    end
                    RemoteRBAAL.put_list(failing_tags)
                elsif cmd[0..0] == "m"
                    if $opt_verbose_fmbt_log and not Fmbt.simulated()
                        # write variable values to fmbt log
                        state_str = @aal.state()
                        log_str = "AAL state #{state_str.count("\n") + 1}\n#{state_str}"
                        # write enabled actions to fmbt log
                        begin
                    
                            log_str += "\nAAL enabled " + @aal._enabled_actions_stack[-1].join(" ")
                        rescue Exception=>e
                        end
                        RemoteRBAAL.fmbtlog(log_str)
                    end
                    action_number = cmd[1..-1].to_i
                    begin
                        rv = @aal.model_execute(action_number)
                    rescue Exception=>e
                        RemoteRBAAL.report_simulation_error(@aal)
                        RemoteRBAAL.fmbtstderr("Error at body() of \"#{action_names[action_number-1]}\" #{e.class} #{e.message}\n#{format_rubyaalrescueion}")
                        raise Exception.new(e.message)
                    else
                        RemoteRBAAL.put(rv)
                    end
                elsif cmd[0..1] == "ap"
                    adapter_call_arguments.push(cmd[2..-1])
                elsif cmd[0..0] == "a"
                    action_number = cmd[1..-1].to_i
                    begin
                        rv = @aal.adapter_execute(action_number,adapter_call_arguments)
                        if rv == nil or rv == true
                            rv = action_number
                        end
                        if (rv.class.to_s == "Fixnum" and (rv == 0 or rv > action_names.length)) or (rv.class.to_s != "Fixnum")
                            RemoteRBAAL.fmbtstderr("adapter() of action \"#{action_names[action_number-1]}\" returned #{rv}")
                            rv = 0
                        end
                    rescue Exception=>e
                        #todo: find  what is Assertion for
                        msg = "Assertion failure"
                        RemoteRBAAL.fmbtstderr("#{msg} at adapter() of \"#{action_names[action_number-1]}\" #{e.class} #{e.message}\n#{format_pythonaalrescueion()}")
                        rv = 0
                    end
                    RemoteRBAAL.put(rv)
                    adapter_call_arguments = []
                elsif cmd[0..2] == "lts"
                    lsts_depth = cmd[3..3].to_i
                    outfilestring = StringIO.new()
                    begin
                        RemoteRBAAL.aal2lsts(@aal, outfilestring, lsts_depth, 
                            discard_variables=nil,include_variables=nil,
                            include_generation_discontinued_tag=false,
                            drop_outputs=$opt_accel_drop_outputs)
                    rescue Exception=>e
                        RemoteRBAAL.report_simulation_error(@aal)
                        RemoteRBAAL.fmbtstderr("Error on simulation #{e.class} #{e.message}\n#{RemoteRBAAL.format_rubyaalrescueion(e)}")
                        RemoteRBAAL.error(e.to_s)
                    end
                    outfilestring.seek(0)
                    RemoteRBAAL.put_lts(outfilestring.read())
                else
                    raise Exception.new("Unexpected command \"" + cmd + "\". remote_rbaal works with \"aal_remote\" model.")
                end
                cmd = $stdin.gets
        end
        end
    end

    def format_rubyaalrescueion(exception)
        tb = exception.backtrace
        tb = tb.reverse()
        new_tb = []
        for file_line_module_code in tb
            if file_line_module_code[0].end_with?("aalmodel.rb")
                break
            end
            new_tb.push(file_line_module_code)
        end
        new_tb = new_tb.reverse()
        return 'Traceback (most recent call last)\n' + new_tb.join(" ")
    end

    def format_syntaxerror()
        """modify last rescueion filename and line number if it's AAL"""
        redefline = re.compile('    def [a-z0-9_]+\(\)')
        recodefileline = re.compile('setCodeFileLine\(.*\'\'\'(.*)\'\'\', ([-0-9]+)[^0-9]')
        exc_type, exc_value, exc_tb = sys.exc_info()
        tb_tuples = traceback.extract_tb(exc_tb)
        filename, syntaxerrorlineno = exc_value.filename, exc_value.lineno
        begin
            fullsource = file(filename).read()
            fullsourcelines = fullsource.split('\n')
            # syntax error is inside the block that starts on line deflineno
            defline = redefline.findall('\n'.join(fullsourcelines[syntaxerrorlineno-1]))[-1]
            deflineno = fullsourcelines.index(defline) + 1
            # that block defined is in an aal file given on next setCodeFileLine
            codefile, aalblockstart = recodefileline.findall('\n'.join(fullsourcelines[syntaxerrorlineno-1]))[0]
            aalblocklineno = syntaxerrorlineno - deflineno
            exc_value.lineno = int(aalblockstart) + aalblocklineno
            exc_value.filename = codefile
            exc_value.args = [exc_value.args[0],[exc_value.filename, exc_value.lineno, exc_value.args[1][2], exc_value.args[1][3]]]
            sys.last_value = exc_value
        rescue
        end
    end

    def report_simulation_error(aal)
        if aal.stack_executed_actions.length > 0
            executed_actions = []
            for l in aal.stack_executed_actions
                executed_actions.push(l)
            end
            RemoteRBAAL.fmbtstderr("Error after simulated execution\n    #{executed_actions.join('\n    ')}")
        end
    end

    def tagfilter(state, tags)
        for tag in $filter_tags
            if tags.include?(tag)
                return tag
            end
        end
        return state
    end

    def aal2lsts(aal, output_fileobj, depth=5, discard_variables=nil,
                include_variables=nil, include_generation_discontinued_tag=true,
                _filter_tags=nil, drop_outputs=false)
        require "lsts.rb"
        def update_generated_tags(aal, include_variables,
                                generated_tagnames, tags, new_lsts_state_num)
            for v in include_variables
                t = "var#{v} = #{aal._variables[v][42]}"
                if !generated_tagnames.include?(t) 
                    generated_tagnames.add(t)
                    tags[t] = []
                end
                tags[t].push(new_lsts_state_num)
            end
        end
        if drop_outputs
            get_actions = 'getIActions'
        else
            get_actions = 'getActions'
        end
        aal.push()
        generation_discontinued_tag = "AAL-depth#{depth}"

        new_lsts = Lsts::Writer.new()
        actionnames = ["tau"] + aal.getActionNames()
        transitions = [[]]
        tags = {generation_discontinued_tag=>[]}
        tagnames = aal.getSPNames()
        generated_tagnames = Set.new([])
        index = 1 
        tagnum_to_name ={}
        for name in tagnames
            tagnum_to_name[index] = name
            tags[name] = []
            index += 1
        end

        tagnames.each_with_index{|_t,num|
            num += 1
            if _filter_tags and _filter_tags.include?(_t)
                _filter_tags.push(num)
            end
        }
        current_tags = aal.getprops()
        initial_state_hidden = RemoteRBAAL.tagfilter(aal.state(discard_variables, include_variables), current_tags)
        initial_state_real = aal.state()
        # unhandled states is a list of
        # (state-string, state-obj, len(shortest path from the initial state))
        unhandled_states = [[initial_state_real, aal.state_obj(), 0]]
        found_states_real = {initial_state_real=>initial_state_hidden} # real to hidden states
        lsts_states = {initial_state_hidden=>0} # state to LSTS state number
        states = 1

        no_filtering_nor_abstracting = (not discard_variables and
                                        not include_variables and
                                        not _filter_tags)

        # initial state tags
        for tag in current_tags
            tags[tagnum_to_name[tag]].push(lsts_states[initial_state_hidden])
        end
        if include_variables
            update_generated_tags(aal, include_variables, generated_tagnames, tags, 0)
        end
        #find State_props(tags) and transitions
        while unhandled_states.length > 0
            source_state, source_state_obj, source_state_depth = unhandled_states.pop()
            source_lsts_state = lsts_states[found_states_real[source_state]]

            if source_state_depth >= depth
                if (include_generation_discontinued_tag and !tags[generation_discontinued_tag].include?(source_lsts_state))
                    tags[generation_discontinued_tag].push(source_lsts_state)
                end
                next
            end
            aal.set_state_obj(source_state_obj)
            for action in aal.send(get_actions)
                copied_source_state_obj = aal.state_obj_copy(source_state_obj)
                aal.set_state_obj(copied_source_state_obj)
                aal.model_execute(action)
                current_tags = aal.getprops()
                next_state_real = aal.state()
                if no_filtering_nor_abstracting
                    next_state_hidden = next_state_real
                else
                    if discard_variables or include_variables
                        next_state_hidden = tagfilter(aal.state(discard_variables, include_variables), current_tags)
                    else
                        next_state_hidden = tagfilter(next_state_real, current_tags)
                    end
                end
                next_state_obj = aal.state_obj()
                # new state?
                if not lsts_states.include?(next_state_hidden)
                    transitions.push([])
                    new_lsts_state_num = transitions.length - 1
                    lsts_states[next_state_hidden] = new_lsts_state_num
                    if include_variables
                        update_generated_tags(aal, include_variables, generated_tagnames, tags, new_lsts_state_num)
                    end
                end
                if not found_states_real.include?(next_state_real)
                    unhandled_states.push([next_state_real, next_state_obj, source_state_depth + 1])
                    found_states_real[next_state_real] = next_state_hidden
                    next_lsts_state_num = lsts_states[next_state_hidden]
                    for tag in current_tags
                        tagname = tagnum_to_name[tag]
                        if not tags[tagname].include?(next_lsts_state_num) 
                            tags[tagname].push(next_lsts_state_num)
                        end
                    end
                end
                if not transitions[source_lsts_state].include?([lsts_states[next_state_hidden],action])
                    transitions[source_lsts_state].push([lsts_states[next_state_hidden],action])
                end
            end
        end

        new_lsts.set_actionnames(actionnames)
        new_lsts.set_transitions(transitions)
        new_lsts.set_stateprops(tags)
        stateprop_order = aal.getSPNames() + generated_tagnames.sort()
        if include_generation_discontinued_tag
            stateprop_order.push(generation_discontinued_tag)
        end
        new_lsts.write(output_fileobj, stateprop_order=stateprop_order)
        aal.pop()
    end
end

$stdout.binmode
$stderr.binmode
STDOUT.set_encoding("UTF-8")

doc_string = %{
Usage: remote_pyaal [options] aalfile 
Runs remote model & adapter written in AAL/Python. aalfile is a
AAL/Python file or Python generated by fmbt-aalc. 
Options:
    -c <string>
        execute the string in the Python interpreter before loading
        aalfile.

    -D flag
        pass -D flag to AAL compiler and preprocessor, used in ifdef's.

    -I include-dir
        Pass -I include-dir to AAL compiler and preprocessor. If AAL
        contains ^include \"filename\"'s, filename will be looked for in
        include-dir.

    -l, -L, --log-file= filename
        Write log to the given file. By default no log is written.
        -l , --log-file overwrites the file, -L pushs.

    --log-unbuffered
        Write log entries to log file on every log function call.
        Slows down high-speed test runs.

    -t, --timeout s
        Event observation timeout in seconds.

    --verbose-fmbt-log
        Write variable values and enabled actions to fMBT log.

    -o, --output filename
        Convert AAL/Python model to LSTS and write output to given
        file. If filename is "-", output is written to the standard
        output.

    --lsts-depth n
        Stop AAL/Python to LSTS conversion to the given depth. The
        depth is the number of test steps from the initial state.

    -H, --lsts-hide-var varname
        Ignore value of varname when converting to LSTS. States which
        differ only by ignored variables are considered the
        same. --lsts-hide-var can be given several times.

    -S, --lsts-show-var varname
        Take variable varname into account when converting to
        LSTS. --lsts-show-var can be given several times.

    --list-state-vars
        Output list of variables that saved for each state.

    --accel-drop-outputs
        Test generation accelerator considers only input actions.
        Safely improves performance outputs in the model are not ment
        to be covered (for instance, they are used for observing
        exceptional behaviour).

    -d, --debug
        Run in debug mode.

    --profile FILE
        Run with profiler, write statistics to FILE.
        Print statistics from FILE with:
        python -c 'import pstats; pstats.Stats(\"FILE\").print_stats()'
}
# Default values for commandline arguments
$log_filename = nil
opt_timeout = 1.0
opt_ppflags = []
opt_output_fileobj = nil
$opt_verbose_fmbt_log = 0
opt_lsts_depth = 5
opt_lsts_hide_vars = []
opt_lsts_show_vars = []
opt_c_exec_statements = []
opt_lsts_hide_tags = []
opt_list_state_vars = false
$opt_accel_drop_outputs = false

# Parse arguments
opts = GetoptLong.new(
    [ "--help", "-h", GetoptLong::NO_ARGUMENT ],
    [ "--c", "-c", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--D", "-D", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--log-file=", "-l", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--timeout=", "-t", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--output=", "-o", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--debug", "-d", GetoptLong::NO_ARGUMENT ],
    [ "--lsts-hide-var=", "-H", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--lsts-show-var=", "-S", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--version", "-V", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--T", "-T", GetoptLong::REQUIRED_ARGUMENT ], 
    [ "--I", "-I", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--verbose-fmbt-log",  GetoptLong::REQUIRED_ARGUMENT ], 
    [ "--accel-drop-outputs", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--lsts-depth=", GetoptLong::REQUIRED_ARGUMENT ], 
    [ "--log-unbuffered", GetoptLong::REQUIRED_ARGUMENT ], 
    [ "--list-state-vars",  GetoptLong::REQUIRED_ARGUMENT ], 
    [ "--profile=", GetoptLong::REQUIRED_ARGUMENT ])
opts.each do |opt, arg|
    if ["-T"].include?(opt)
        opt_lsts_hide_tags.push(arg)
    elsif ["-d", "--debug"].include?(opt) 
        $opt_debug += 1
    elsif ["-c"].include?(opt) 
        opt_c_exec_statements.push(arg)
    elsif ["-D"].include?(opt) 
        opt_ppflags += ['-D' , arg]
    elsif ["-I"].include?(opt) 
        opt_ppflags += ['-I' , arg]
    elsif ['-V', '--version'].include?(opt) 
        begin
            import fmbt_config
            print "Version " + fmbt_config.fmbt_version + fmbt_config.fmbt_build_info
        rescue
            print "Version N/A"
        end
        sys.exit(0)
    elsif ["-h", "--help"].include?(opt) 
        print doc_string
        exit(0)
    elsif ["-l", "-L", "--log-file"].include?(opt) 
        $log_filename = arg
        if opt != "-L"
            file($log_filename, "w") # overwrite
            end
    elsif ["--log-unbuffered"].include?(opt) 
        $opt_log_unbuffered = true
    elsif ["-t", "--timeout"].include?(opt) 
        opt_timeout = float(arg)
        RemoteRBAAL::MyLog("observe timeout #{opt_timeout}")
    elsif ["--verbose-fmbt-log"].include?(opt) 
        $opt_verbose_fmbt_log += 1
    elsif ["-o", "--output"].include?(opt) 
        if arg == "-"
            opt_output_fileobj = $stdout
        else
            opt_output_fileobj = file(arg, "w")
        end
    elsif ["--lsts-depth"].include?(opt) 
        opt_lsts_depth = int(arg)
    elsif ["-H", "--lsts-hide-var"].include?(opt)  
        opt_lsts_hide_vars.push(arg)
    elsif ["-S", "--lsts-show-var"].include?(opt)  
        opt_lsts_show_vars.push(arg)
    elsif ["--list-state-vars"].include?(opt)  
        opt_list_state_vars = true
        if not opt_output_fileobj
            opt_output_fileobj = $stdout
        end
    elsif ["--accel-drop-outputs"].include?(opt)  
        $opt_accel_drop_outputs = true
    elsif ["--profile"].include?(opt)  
        $opt_profile = arg
    end
end

if ARGV.length != 1
    print doc_string
end
    
aal_filename = ARGV[0]

if aal_filename[aal_filename.length-4,aal_filename.length] == '.aal'
    cmd = "fmbt-aalc -l ruby #{opt_ppflags.join(" ")} #{aal_filename}"
    begin
        aal_code = `#{cmd}`
    rescue Exception => e
        errmsg = ("converting aal to ruby with command #{cmd} failed. status=#{e.message}\n")
        RemoteRBAAL.fmbtstderr(errmsg)
        raise Exception.new(errmsg)
    end
    if not aal_code
        aalfile_full_path = ENV['AAL_INCLUDE_PREFIX'] + "/" + aal_filename
        if not File.exist?(aalfile_full_path)
            errmsg = "is file \"#{aalfile_full_path}\" readable?"
            RemoteRBAAL.fmbtstderr(aal_code)
            raise Exception.new(errmsg)
        end
    end
else
    begin
        aal_code = file(aal_filename).read()
    rescue Exception=>e
        raise Exception.new("reading file '#{aal_filename}' failed #{e.message}")
    end
end

#executing command line passed in 
for statement in opt_c_exec_statements
    begin
        RemoteRBAAL::MyLog("Executing command line argument '%s'" % statement)
        exec statement
    rescue Exception=>e
        RemoteRBAAL.fmbtstderr("rescueion from command line argument \"#{statement}\"\n#{traceback.format_exc()}")
        raise Exception.new("No rescueions allowed, got '#{e}'\n#{traceback.format_exc()}")
    end
end

#create temp class file
begin
    aalrb_file = Tempfile.new(["remote_rbaal",".rb"])
    aal_code = aal_code.gsub("\r\n", "\n")
    aalrb_file.write(aal_code)
    aalrb_file.close()
    aalrb_filename = aalrb_file.path
rescue Exception=>e
    RemoteRBAAL.fmbtstderr('error in creating file')
    RemoteRBAAL.fmbtstderr(e.class + " " + e.message)
end

#load temp class file generated from aal file
begin
    # $stdout.write("internal encoding #{STDOUT.internal_encoding} \n")
    # $stdout.write("external encoding #{STDOUT.external_encoding} \n")
    # $stdout.write("Navigator2 MML自动化组件 v1.1.7.1\n")
    # $stdout.flush
    load(aalrb_filename)
rescue Exception=>e
    # todo: haven't run yet
    if e.class == "SyntaxError"
        format_syntaxerror()
    end
    code_lines = aal_code.split('\n')
    index = 1
    @code_with_line_nums = []
    for line in code_lines
        @code_with_line_nums.push("#{index+1}  #{line}")
        index += 1
    end
    RemoteRBAAL::MyLog.log(@code_with_line_nums.join("\n"))
    RemoteRBAAL.fmbtstderr("Executing #{aal_filename} failed #{e.class} #{e.message}\n")
    raise Exception.new("executing aal code failed\n#{e.message}\n")
end

# Generated AAL code exports generated AAL class as "Model".
# Model is inherited from AALModel in aalmodel.rb.
begin
    
    aal = Model.new()
    aal.log = RemoteRBAAL::MyLog
    aal.timeout = opt_timeout
    aal.instance_variable_get(:@variables)['fmbtlog'] = 'fmbtlog'
    aal.instance_variable_get(:@variables)['fmbtlograw'] = 'fmbtlograw'
    aal.instance_variable_get(:@variables)['__file__'] = aal_filename
rescue Exception=>e
    RemoteRBAAL.fmbtstderr(aalrb_filename)
    RemoteRBAAL.fmbtstderr("Error when instantiating Model() #{e.class}\n#{e.message}")
    raise Exception.new("Error when instantiating Model() #{e.class}\n#{e.message}")
end



if $opt_profile
    import cProfile
    profiler = cProfile.Profile()
    profiler.enable()
end

if not opt_output_fileobj
    g_bridge = RemoteRBAAL::RemoteAALBridge.new(aal)
    RemoteRBAAL::MyLog.log("starting")
    at_exit do
        RemoteRBAAL::bye(g_bridge)
    end
    g_bridge.communicate()
elsif opt_list_state_vars
    aal.reset()
    # opt_output_fileobj.write( "\n".join([l.split(" = ",1)[0] for l in sorted(aal.state().splitlines())]))
    opt_output_fileobj.write("\n")
    opt_output_fileobj.close()
else # output LSTS
    aal.reset()
    begin
        aal2lsts(aal, opt_output_fileobj, depth=opt_lsts_depth, discard_variables=set(opt_lsts_hide_vars), include_variables=set(opt_lsts_show_vars),_filter_tags=opt_lsts_hide_tags)
    rescue rescueion=>e
        report_simulation_error(aal)
        RemoteRBAAL.fmbtstderr("Error on simulation #{e.class} #{e.message}\n#{format_pythonaalrescueion()}")
    end
    opt_output_fileobj.close()
end

if $opt_profile
    profiler.disable()
    s = profiler.dump_stats($opt_profile)
end